根据中位数的特点，分为大小相等的两部分，左边集的数字总比右边集的数字小
所以，有了一下两个条件：
$$
<1>.len(left\_part)=len(right\_part)\\
<2>.\max({left\_part}) \leq \min({righ\_part})max(left\_part)≤min(right\_part)
$$
只要满足这个条件，那么：
$$
median= 
\frac  {max(left\_part)+min(right\_part)} 2
$$
所以为了满足这两个条件，我们在第一个条件满足的情况下，让j 用i 可以表示出来，然后对 i 进行遍历，直到找到满足的条件。
$$
 i=0∼m, j= \frac 
{m+n+1}
 2−i
$$
所以，最终会遇到三种情况：
$$
1.(j=0~~~or ~~i = m~ or~~ \text{B}[j-1] \leq \text{A}[i]) 或是\\(i=0 ~or~ j = n~ or ~\text{A}[i-1] \leq \text{B}[j])，这意味着 i 是完美的，我们可以停止搜索。\\
\\
2.j > 0 ~and ~i < m ~and ~B[j−1]>A[i] 这意味着 i 太小，我们必须增大它。\\
3.i > 0~and~ j < n~ and~ A[i−1]>B[j] 这意味着 i 太大，我们必须减小它。\\

$$


# 代码
```Python
class Solution():
    def findMedianSortedArrays(self, s1, s2):
        return self.median(s1,s2)
    def median(self,A, B):
        m, n = len(A), len(B)
        if m > n:
            A, B, m, n = B, A, n, m
        if n == 0:
            raise ValueError

        imin, imax, half_len = 0, m, (m + n + 1) / 2
        while imin <= imax:
            i = (imin + imax) / 2
            j = half_len - i
            if  i > 0 and A[i-1] > B[j]:
                # i is too big, must decrease it
                imax = i - 1
            elif i < m and B[j-1] > A[i]:
                # i is too small, must increase it
                imin = i + 1
            else:
                # i is perfect

                if i == 0: max_of_left = B[j-1]
                elif j == 0: max_of_left = A[i-1]
                else: max_of_left = max(A[i-1], B[j-1])

                if (m + n) % 2 == 1:
                    return max_of_left

                if i == m: min_of_right = B[j]
                elif j == n: min_of_right = A[i]
                else: min_of_right = min(A[i], B[j])

                return (max_of_left + min_of_right) / 2.0
```
