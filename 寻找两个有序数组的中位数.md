中位数：

将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 

根据此定义，只要考虑到，满足下列条件的时候，我们就可以找到中位数。

1.   len(left_part)=len(right_part)         *i*=0∼*m*,  
   $$
   j=\frac {\text m +n+1} 2 -i
   $$
   

2.  max(left_part)≤min(right_part) 
   $$
   B[j−1]≤A[i] 以及A[i−1]≤B[j]
   $$
   

但是如何满足这两个条件呢，我们可以在第一个条件的满足下，也就是让j用i来表示，然后遍历i，找到满足第二个条件的i.

所以，最终算法形式就是这样：

```
i--[0,m]   
	j=(m+n+1)/2-i
    if i > 0 and A[i-1] > B[j]  -------i--
    if i < m and B[j-1] > A[i]	-------i++
    else  找到了最佳位置。
max(A[i−1],B[j−1]),   当 m + n为奇数时
max(A[i−1],B[j−1])+min(A[i],B[j])/2,	当 m + n为偶数时
```



# 代码
```Python
class Solution():
    def findMedianSortedArrays(self, s1, s2):
        return self.median(s1,s2)
    def median(self,A, B):
        m, n = len(A), len(B)
        if m > n:
            A, B, m, n = B, A, n, m
        if n == 0:
            raise ValueError

        imin, imax, half_len = 0, m, (m + n + 1) / 2
        while imin <= imax:
            i = (imin + imax) / 2
            j = half_len - i
            if  i > 0 and A[i-1] > B[j]:
                # i is too big, must decrease it
                imax = i - 1
            elif i < m and B[j-1] > A[i]:
                # i is too small, must increase it
                imin = i + 1
            else:
                # i is perfect

                if i == 0: max_of_left = B[j-1]
                elif j == 0: max_of_left = A[i-1]
                else: max_of_left = max(A[i-1], B[j-1])

                if (m + n) % 2 == 1:
                    return max_of_left

                if i == m: min_of_right = B[j]
                elif j == n: min_of_right = A[i]
                else: min_of_right = min(A[i], B[j])

                return (max_of_left + min_of_right) / 2.0
```

参考：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/